sw.js:
// sw.js â€“ Complete Service Worker with error-tolerant install handler
// Using Workbox for better caching strategies

importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js');
importScripts('https://cdn.jsdelivr.net/npm/idb-keyval@6.2.2/dist/umd.min.js');

const { createStore, set, get, keys, del, entries } = idbKeyval;

// IndexedDB stores
const notificationStore = createStore('notifications-db', 'notifications');
const dataStore = createStore('data-db', 'story-data');
const settingsStore = createStore('settings-db', 'notification-settings');
const viewedStore = createStore('viewed-db', 'viewed-notifications');

// Cache config
const isDev = ['localhost', '127.0.0.1'].includes(self.location.hostname) || self.location.protocol === 'file:';
const CACHE_NAME = isDev ? 'storyapp-cache-dev' : 'storyapp-cache-v2';

// Workbox configuration
if (workbox) {
  console.log('Workbox is loaded');
  
  // Custom cache names
  workbox.core.setCacheNameDetails({
    prefix: 'storyapp',
    suffix: 'v2',
    precache: 'precache',
    runtime: 'runtime',
  });
  
  // Precaching static assets
  workbox.precaching.precacheAndRoute([
    { url: '/', revision: '1' },
    { url: '/index.html', revision: '1' },
    { url: '/app.css', revision: '1' },
    { url: '/app.bundle.js', revision: '1' },
    { url: '/manifest.json', revision: '1' },
    { url: '/favicon.png', revision: '1' },
    { url: '/images/icons/android/android-launchericon-192-192.png', revision: '1' },
    { url: '/images/icons/android/android-launchericon-512-512.png', revision: '1' },
    { url: '/images/logo.png', revision: '1' },
  ]);
  
  // Cache external libraries with Network First strategy
  workbox.routing.registerRoute(
    /^https:\/\/unpkg\.com\/.*/,
    new workbox.strategies.NetworkFirst({
      cacheName: 'external-libs',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 20,
          maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        }),
      ],
    })
  );
  
  // Cache API responses with StaleWhileRevalidate
  workbox.routing.registerRoute(
    /^https:\/\/story-api\.dicoding\.dev\/v1\/stories.*/,
    new workbox.strategies.StaleWhileRevalidate({
      cacheName: 'api-responses',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 50,
          maxAgeSeconds: 24 * 60 * 60, // 1 day
        }),
      ],
    })
  );
  
  // Fallback to app shell for navigation requests
  workbox.routing.registerRoute(
    ({ request }) => request.mode === 'navigate',
    new workbox.strategies.NetworkFirst({
      cacheName: 'pages',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 10,
          maxAgeSeconds: 24 * 60 * 60, // 1 day
        }),
      ],
    })
  );
  
  // Cache images with Cache First strategy
  workbox.routing.registerRoute(
    /\.(?:png|jpg|jpeg|svg|gif)$/,
    new workbox.strategies.CacheFirst({
      cacheName: 'images',
      plugins: [
        new workbox.expiration.ExpirationPlugin({
          maxEntries: 60,
          maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        }),
      ],
    })
  );
} else {
  console.log('Workbox failed to load, falling back to basic caching');
  
  // INSTALL â€“ cache each URL, skip failures (fallback if Workbox fails)
  self.addEventListener('install', event => {
    const urlsToCache = [
      '/', '/index.html', '/app.css', '/app.bundle.js', '/app.bundle.js.LICENSE.txt',
      '/manifest.json', '/favicon.png',
      '/images/icons/android/android-launchericon-192-192.png',
      '/images/icons/android/android-launchericon-512-512.png', '/images/logo.png',
      'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
      'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
      'https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css',
      'https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js'
    ];
    
    event.waitUntil((async () => {
      const cache = await caches.open(CACHE_NAME);
      for (const url of urlsToCache) {
        try {
          await cache.add(url);
        } catch (err) {
          console.warn(`Skip caching ${url}:`, err);
        }
      }
      await self.skipWaiting();
    })());
  });

  // FETCH â€“ cache-first with offline fallback (fallback if Workbox fails)
  self.addEventListener('fetch', event => {
    if (event.request.method !== 'GET') return;
    event.respondWith(caches.match(event.request).then(cached => {
      if (cached) return cached;
      return fetch(event.request)
        .then(resp => {
          if (resp.ok && resp.type === 'basic' && event.request.url.startsWith(self.location.origin)) {
            const clone = resp.clone();
            caches.open(CACHE_NAME).then(c => c.put(event.request, clone));
          }
          return resp;
        })
        .catch(() => {
          if (event.request.mode === 'navigate') return caches.match('/index.html');
        });
    }));
  });
}

// ACTIVATE â€“ clear old caches, register periodic sync, init settings
self.addEventListener('activate', event => {
  event.waitUntil(Promise.all([
    caches.keys().then(names =>
      Promise.all(
        names
          .filter(n => n.startsWith('storyapp-') && n !== CACHE_NAME && !n.includes('workbox'))
          .map(n => caches.delete(n))
      )
    ),
    (async () => {
      if ('periodicSync' in self.registration) {
        try {
          await self.registration.periodicSync.register('fetch-new-stories', { minInterval: 24 * 60 * 60 * 1000 });
          await self.registration.periodicSync.register('store-periodic-notifications', { minInterval: 15 * 60 * 1000 });
          await self.registration.periodicSync.register('cleanup-old-notifications', { minInterval: 6 * 60 * 60 * 1000 });
        } catch (e) { console.warn('PeriodicSync unavailable', e) }
      }
    })(),
    initDummyNotificationSettings()
  ]).then(() => self.clients.claim()));
});

// VAPID helper
function urlB64ToUint8Array(b64) {
  const padding = '='.repeat((4 - b64.length % 4) % 4);
  const bin = atob(b64.replace(/-/g, '+').replace(/_/g, '/') + padding);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return arr;
}
const VAPID_PUBLIC = 'BCCs2eonMI-6H2ctvFaWg-UYdDv387Vno_bzUzALpB442r2lCnsHmtrx8biyPi_E-1fSGABK_Qs_GlvPoJJqxbk';

// PUSH â€“ store & display
self.addEventListener('push', event => {
  let data = {}, title = 'Notifikasi', options = {};
  try { data = event.data.json(); title = data.title; options = data.options; } catch { }
  const id = Date.now().toString();
  event.waitUntil(
    set(id, { title, options, timestamp: Date.now(), read: false }, notificationStore)
      .then(() => self.registration.showNotification(title, options))
  );
});

// Notification click â€“ focus / open & mark as read
self.addEventListener('notificationclick', event => {
  event.notification.close();
  event.waitUntil((async () => {
    // Mark notification as read based on tag if available
    if (event.notification.tag) {
      const allKeys = await keys(notificationStore);
      for (const key of allKeys) {
        const notif = await get(key, notificationStore);
        if (notif.options && notif.options.tag === event.notification.tag) {
          await set(key, { ...notif, read: true }, notificationStore);
          // Also mark it as viewed
          await set(key, true, viewedStore);
        }
      }
    }
    
    // Focus or open window
    const allClients = await clients.matchAll({ type: 'window', includeUncontrolled: true });
    for (const client of allClients) {
      if (client.url === '/' && client.focus) {
        await client.focus();
        return;
      }
    }
    if (clients.openWindow) await clients.openWindow('/');
  })());
});

// Subscription change â€“ renew
self.addEventListener('pushsubscriptionchange', event => {
  event.waitUntil(
    self.registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: urlB64ToUint8Array(VAPID_PUBLIC)
    }).then(sub => fetch('https://story-api.dicoding.dev/v1/notifications/subscribe', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(sub)
    }))
  );
});

// Periodic & Background sync
self.addEventListener('periodicsync', e => {
  if (e.tag === 'fetch-new-stories') e.waitUntil(fetchNewStories());
  if (e.tag === 'store-periodic-notifications') e.waitUntil(storePeriodicNotification());
  if (e.tag === 'cleanup-old-notifications') e.waitUntil(cleanupOldNotifications());
});

self.addEventListener('sync', e => {
  if (e.tag === 'fetch-new-stories') e.waitUntil(fetchNewStories());
  if (e.tag === 'store-periodic-notifications') e.waitUntil(storePeriodicNotification());
  if (e.tag === 'cleanup-old-notifications') e.waitUntil(cleanupOldNotifications());
});

// MESSAGE â€“ handle client commands
self.addEventListener('message', event => {
  const cmd = event.data;
  if (cmd === 'FLUSH_NOTIFICATIONS') event.waitUntil(flushNotifications(event.source.id));
  if (cmd === 'MARK_ALL_AS_READ') event.waitUntil(markAllNotificationsAsRead());
  if (cmd === 'DELETE_NOTIFICATION') event.waitUntil(deleteNotification(cmd.id));
  if (cmd.command === 'SET_DUMMY_NOTIFICATIONS') event.waitUntil(setDummyNotificationSettings(cmd.enabled));
  if (cmd === 'GET_DUMMY_NOTIFICATIONS_STATUS') event.waitUntil(getDummyNotificationStatus(event.source.id));
  if (cmd === 'FETCH_NEW_STORIES') event.waitUntil(fetchNewStories());
});

// -- Helper Functions --

// Create and store a periodic notification
async function storePeriodicNotification() {
  const ts = Date.now(), id = `periodic-${ts}`, title = 'Notifikasi Periodik';
  const opts = { 
    body: `Update cerita terbaru @ ${new Date(ts).toLocaleString()}`, 
    icon: '/favicon.png', 
    tag: 'periodic', 
    timestamp: ts 
  };
  
  await set(id, { title, options: opts, timestamp: ts, read: false }, notificationStore);
  
  // Notify all clients
  (await clients.matchAll({ type: 'window' })).forEach(c =>
    c.postMessage({ 
      type: 'NEW_NOTIFICATION', 
      notification: { id, title, options: opts, timestamp: ts } 
    })
  );
  
  // Show system notification
  await self.registration.showNotification(title, opts);
}

// Fetch new stories from API
async function fetchNewStories() {
  try {
    // Get token from IndexedDB if available
    const authData = await get('authData', dataStore);
    if (!authData || !authData.token) {
      console.log('No auth token available, fetching as guest');
      return fetchStoriesAsGuest();
    }
    
    // Fetch with auth token
    const res = await fetch('https://story-api.dicoding.dev/v1/stories?page=1&size=10', {
      headers: {
        'Authorization': `Bearer ${authData.token}`
      }
    });
    
    if (!res.ok) {
      console.error('Failed to fetch stories:', res.status);
      return;
    }
    
    const data = await res.json();
    
    // Store full response in IndexedDB for offline access
    await set('latestStories', data, dataStore);
    
    // Get last seen story ID
    const lastSeenId = await get('lastSeenStoryId', dataStore);
    
    // Create notifications for new stories
    let newStoriesCount = 0;
    for (const story of data.listStory) {
      if (story.id === lastSeenId) break;
      
      const ts = Date.now();
      const id = `story-${story.id}-${ts}`;
      const title = `Story baru dari ${story.name}`;
      const opts = { 
        body: story.description.substring(0, 100) + (story.description.length > 100 ? '...' : ''),
        icon: '/favicon.png', 
        image: story.photoUrl,
        data: { storyId: story.id, url: story.photoUrl },
        tag: `story-${story.id}`,
        timestamp: ts 
      };
      
      // Store notification
      await set(id, { title, options: opts, timestamp: ts, storyData: story, read: false }, notificationStore);
      
      // Show system notification (limit to prevent overwhelming the user)
      if (newStoriesCount < 3) {
        await self.registration.showNotification(title, opts);
      }
      
      newStoriesCount++;
    }
    
    // Update last seen ID if we have new stories
    if (data.listStory.length > 0) {
      await set('lastSeenStoryId', data.listStory[0].id, dataStore);
    }
    
    // Notify clients about new stories count
    if (newStoriesCount > 0) {
      (await clients.matchAll({ type: 'window' })).forEach(client =>
        client.postMessage({ 
          type: 'NEW_STORIES_COUNT', 
          count: newStoriesCount 
        })
      );
    }
    
    return newStoriesCount;
  } catch (e) {
    console.error('Error fetching stories:', e);
  }
}

// Fetch stories as guest
async function fetchStoriesAsGuest() {
  try {
    const res = await fetch('https://story-api.dicoding.dev/v1/stories?page=1&size=10');
    
    if (!res.ok) {
      console.error('Failed to fetch stories as guest:', res.status);
      return;
    }
    
    const data = await res.json();
    
    // Store response in IndexedDB
    await set('guestStories', data, dataStore);
    
    // Get last seen story ID
    const lastSeenId = await get('lastSeenStoryId', dataStore);
    
    // Create only one notification for guest users to avoid spam
    if (data.listStory.length > 0 && data.listStory[0].id !== lastSeenId) {
      const ts = Date.now();
      const id = `guest-stories-${ts}`;
      const title = 'Cerita baru tersedia';
      const opts = { 
        body: `Ada ${data.listStory.length} cerita baru tersedia! Login untuk melihat lebih banyak.`,
        icon: '/favicon.png',
        tag: 'guest-stories',
        timestamp: ts 
      };
      
      // Store notification
      await set(id, { title, options: opts, timestamp: ts, read: false }, notificationStore);
      
      // Show system notification
      await self.registration.showNotification(title, opts);
      
      // Update last seen ID
      await set('lastSeenStoryId', data.listStory[0].id, dataStore);
      
      return 1; // Return count of notifications
    }
    
    return 0;
  } catch (e) {
    console.error('Error fetching stories as guest:', e);
    return 0;
  }
}

// Send stored notifications to client
async function flushNotifications(clientId) {
  try {
    // Get all notifications
    const allEntries = await entries(notificationStore);
    const notifications = allEntries.map(([key, value]) => ({
      id: key,
      ...value
    }));
    
    // Sort by timestamp (newest first)
    notifications.sort((a, b) => b.timestamp - a.timestamp);
    
    // Get client and send notifications
    const client = await clients.get(clientId);
    if (client) {
      client.postMessage({ 
        type: 'PENDING_NOTIFICATIONS', 
        notifications: notifications 
      });
    }
  } catch (e) {
    console.error('flushNotifications error', e);
  }
}

// Mark all notifications as read
async function markAllNotificationsAsRead() {
  try {
    const allEntries = await entries(notificationStore);
    
    for (const [key, value] of allEntries) {
      if (!value.read) {
        await set(key, { ...value, read: true }, notificationStore);
        // Also mark as viewed
        await set(key, true, viewedStore);
      }
    }
    
    // Notify clients
    (await clients.matchAll({ type: 'window' })).forEach(client =>
      client.postMessage({ type: 'NOTIFICATIONS_MARKED_READ' })
    );
    
    return true;
  } catch (e) {
    console.error('markAllNotificationsAsRead error', e);
    return false;
  }
}

// Delete a specific notification
async function deleteNotification(notificationId) {
  try {
    await del(notificationId, notificationStore);
    await del(notificationId, viewedStore);
    
    // Notify clients
    (await clients.matchAll({ type: 'window' })).forEach(client =>
      client.postMessage({ 
        type: 'NOTIFICATION_DELETED', 
        id: notificationId 
      })
    );
    
    return true;
  } catch (e) {
    console.error('deleteNotification error', e);
    return false;
  }
}

// Clean up old notifications
async function cleanupOldNotifications() {
  try {
    const allEntries = await entries(notificationStore);
    const cutoff = Date.now() - 7 * 24 * 60 * 60 * 1000; // 7 days
    
    const toDelete = allEntries.filter(([_, value]) => {
      // Remove dummy notifications after 1 hour
      if (value.isDummy) return value.timestamp < (Date.now() - 3600 * 1000);
      // Remove read notifications after 7 days
      if (value.read) return value.timestamp < cutoff;
      // Keep unread notifications
      return false;
    }).map(([key]) => key);
    
    // Delete from both stores
    for (const key of toDelete) {
      await del(key, notificationStore);
      await del(key, viewedStore);
    }
    
    if (toDelete.length > 0) {
      console.log(`Cleaned up ${toDelete.length} old notifications`);
    }
    
    return toDelete.length;
  } catch (e) {
    console.error('cleanupOldNotifications error', e);
    return 0;
  }
}

// Initialize dummy notification settings
async function initDummyNotificationSettings() {
  try {
    const s = await get('dummyNotifications', settingsStore);
    if (s === undefined) {
      await set('dummyNotifications', { enabled: false, timerId: null }, settingsStore);
    } else if (s.enabled && s.timerId === null) {
      const tid = startDummyNotificationTimer();
      await set('dummyNotifications', { enabled: true, timerId: tid }, settingsStore);
    }
  } catch (e) {
    console.error('initDummyNotificationSettings', e);
  }
}

// Set dummy notification settings
async function setDummyNotificationSettings(enabled) {
  try {
    const s = await get('dummyNotifications', settingsStore) || { enabled: false, timerId: null };
    
    if (enabled && !s.enabled) {
      const tid = startDummyNotificationTimer();
      await set('dummyNotifications', { enabled: true, timerId: tid }, settingsStore);
      (await clients.matchAll({ type: 'window' })).forEach(c => c.postMessage({ type: 'DUMMY_NOTIFICATIONS_STATUS', enabled: true }));
    } else if (!enabled && s.enabled) {
      clearInterval(s.timerId);
      await set('dummyNotifications', { enabled: false, timerId: null }, settingsStore);
      (await clients.matchAll({ type: 'window' })).forEach(c => c.postMessage({ type: 'DUMMY_NOTIFICATIONS_STATUS', enabled: false }));
    }
  } catch (e) {
    console.error('setDummyNotificationSettings', e);
  }
}

// Get dummy notification status
async function getDummyNotificationStatus(clientId) {
  try {
    const s = await get('dummyNotifications', settingsStore) || { enabled: false };
    const c = await clients.get(clientId);
    if (c) c.postMessage({ type: 'DUMMY_NOTIFICATIONS_STATUS', enabled: s.enabled });
  } catch (e) {
    console.error('getDummyNotificationStatus', e);
  }
}

Dokumentasi API:
Dicoding Story
API untuk berbagi story seputar Dicoding, mirip seperti post Instagram namun special untuk Dicoding.

Endpoint
https://story-api.dicoding.dev/v1

Register
URL
/register
Method
POST
Request Body
name as string
email as string, must be unique
password as string, must be at least 8 characters
Response
{
  "error": false,
  "message": "User Created"
}
Login
URL
/login
Method
POST
Request Body
email as string
password as string
Response
{
    "error": false,
    "message": "success",
    "loginResult": {
        "userId": "user-yj5pc_LARC_AgK61",
        "name": "Arif Faizin",
        "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJ1c2VyLXlqNXBjX0xBUkNfQWdLNjEiLCJpYXQiOjE2NDE3OTk5NDl9.flEMaQ7zsdYkxuyGbiXjEDXO8kuDTcI__3UjCwt6R_I"
    }
}
Add New Story
URL
/stories
Method
POST
Headers
Content-Type: multipart/form-data
Authorization: Bearer <token>
Request Body
description as string
photo as file, must be a valid image file, max size 1MB
lat as float, optional
lon as float, optional
Response
{
    "error": false,
    "message": "success" 
}
Add New Story with Guest Account (without Authentication)
URL
/stories/guest
Method
POST
Request Body
description as string
photo as file, must be a valid image file, max size 1MB
lat as float, optional
lon as float, optional
Response
{
    "error": false,
    "message": "success"
}
Get All Stories
URL
/stories
Parameters
page as int, optional
size as int, optional
location as 1 | 0, optional, default 0
Notes:
1 for get all stories with location
0 for all stories without considering location
Method
GET
Headers
Authorization: Bearer <token>
Response
{
    "error": false,
    "message": "Stories fetched successfully",
    "listStory": [
        {
            "id": "story-FvU4u0Vp2S3PMsFg",
            "name": "Dimas",
            "description": "Lorem Ipsum",
            "photoUrl": "https://story-api.dicoding.dev/images/stories/photos-1641623658595_dummy-pic.png",
            "createdAt": "2022-01-08T06:34:18.598Z",
            "lat": -10.212,
            "lon": -16.002
        }
    ]
}
Detail Story
URL
/stories/:id
Method
GET
Headers
Authorization: Bearer <token>
Response
{
    "error": false,
    "message": "Story fetched successfully",
    "story": {
        "id": "story-FvU4u0Vp2S3PMsFg",
        "name": "Dimas",
        "description": "Lorem Ipsum",
        "photoUrl": "https://story-api.dicoding.dev/images/stories/photos-1641623658595_dummy-pic.png",
        "createdAt": "2022-01-08T06:34:18.598Z",
        "lat": -10.212,
        "lon": -16.002
    }
}
Push Notification (Web Push)
VAPID public keys: BCCs2eonMI-6H2ctvFaWg-UYdDv387Vno_bzUzALpB442r2lCnsHmtrx8biyPi_E-1fSGABK_Qs_GlvPoJJqxbk

Story Notification JSON Schema
{
  "title": "Story berhasil dibuat",
  "options": {
    "body": "Anda telah membuat story baru dengan deskripsi: <story description>"
  }
}
Subscribe
URL
/notifications/subscribe
Method
POST
Headers
Authorization: Bearer <token>
Content-Type: application/json
Request Body
endpoint: string
keys: string
p256dh: string
auth: string
Response
{
"error": false,
"message": "Success to subscribe web push notification.",
"data": {
  "id": "...",
  "endpoint": "...",
  "keys": {
    "p256dh": "...",
    "auth": "..."
  },
  "userId": "...",
  "createdAt": "..."
  }
}
Unsubscribe
URL
/notifications/subscribe
Method
DELETE
Headers
Authorization: Bearer <token>
Content-Type: application/json
Request Body
endpoint: string
Response
{
  "error": false,
  "message": "Success to unsubscribe web push notification."
}

Sekarang, Buat agar sw.js saya, menggunakan indexeddb, untuk mengambil data baru dari api, menyimpannya, dan menampilkan data baru ini secara periodik sebagai notifikasi. Nanti hapus data yang disimpan ini setelah telah dilihat oleh user (atau user pilih untuk hapus).
sw.js:
// sw.js â€“ Service Worker lengkap dengan errorâ€‘tolerant install handler
// 1) Asset caching (cache-first & offline fallback)
// 2) IndexedDB (idb-keyval) untuk notifikasi & state
// 3) Push handling & tampilkan segera
// 4) Background sync / periodic sync
// 5) Flush pending notifications via postMessage
// 6) Push subscription change untuk renew subscription
// 7) Dummy notifications setiap 1 detik (toggle-able)
// 8) Penyimpanan notifikasi periodik & history

importScripts('https://cdn.jsdelivr.net/npm/idb-keyval@6.2.2/dist/umd.min.js');

const { createStore, set, get, keys, del } = idbKeyval;

// IndexedDB stores
const notificationStore = createStore('notifications-db', 'notifications');
const dataStore         = createStore('data-db',          'last-seen-item');
const settingsStore     = createStore('settings-db',      'notification-settings');

// Cache config
const isDev = ['localhost','127.0.0.1'].includes(self.location.hostname) || self.location.protocol==='file:';
const CACHE_NAME = isDev ? 'storyapp-cache-dev' : 'storyapp-cache-v2';
const urlsToCache = [
  '/', '/index.html', '/app.css', '/app.bundle.js', '/app.bundle.js.LICENSE.txt',
  '/manifest.json', '/favicon.png',
  '/images/icons/android/android-launchericon-192-192.png',
  '/images/icons/android/android-launchericon-512-512.png', '/images/logo.png',
  'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css',
  'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js',
  'https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css',
  'https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js'
];

// INSTALL â€“ cache each URL, skip failures
self.addEventListener('install', event => {
  event.waitUntil((async () => {
    const cache = await caches.open(CACHE_NAME);
    for (const url of urlsToCache) {
      try {
        await cache.add(url);
      } catch (err) {
        console.warn(`Skip caching ${url}:`, err);
      }
    }
    await self.skipWaiting();
  })());
});

// ACTIVATE â€“ clear old caches, register periodic sync, init settings
self.addEventListener('activate', event => {
  event.waitUntil(Promise.all([
    caches.keys().then(names =>
      Promise.all(
        names.filter(n => n.startsWith('storyapp-cache-') && n!==CACHE_NAME)
             .map(n => caches.delete(n))
      )
    ),
    (async () => {
      if ('periodicSync' in self.registration) {
        try {
          await self.registration.periodicSync.register('fetch-new-items', { minInterval: 24*60*60*1000 });
          await self.registration.periodicSync.register('store-periodic-notifications', { minInterval: 15*60*1000 });
        } catch(e){ console.warn('PeriodicSync unavailable', e) }
      }
    })(),
    initDummyNotificationSettings()
  ]).then(() => self.clients.claim()));
});

// FETCH â€“ cache-first with offline fallback
self.addEventListener('fetch', event => {
  if (event.request.method !== 'GET') return;
  event.respondWith(caches.match(event.request).then(cached => {
    if (cached) return cached;
    return fetch(event.request)
      .then(resp => {
        if (resp.ok && resp.type==='basic' && event.request.url.startsWith(self.location.origin)) {
          const clone = resp.clone();
          caches.open(CACHE_NAME).then(c => c.put(event.request, clone));
        }
        return resp;
      })
      .catch(() => {
        if (event.request.mode==='navigate') return caches.match('/index.html');
      });
  }));
});

// VAPID helper
function urlB64ToUint8Array(b64) {
  const padding = '='.repeat((4 - b64.length%4)%4);
  const bin     = atob(b64.replace(/-/g,'+').replace(/_/g,'/')+padding);
  const arr     = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i);
  return arr;
}
const VAPID_PUBLIC = 'BCCs2eonMI-6H2ctvFaWg-UYdDv387Vno_bzUzALpB442r2lCnsHmtrx8biyPi_E-1fSGABK_Qs_GlvPoJJqxbk';

// PUSH â€“ simpan & tampilkan
self.addEventListener('push', event => {
  let data={}, title='Notifikasi', options={};
  try { data=event.data.json(); title=data.title; options=data.options; }catch{}
  const id = Date.now().toString();
  event.waitUntil(
    set(id, { title, options, timestamp:Date.now() }, notificationStore)
      .then(()=> self.registration.showNotification(title, options))
  );
});

// Notification click â€“ fokus / buka
self.addEventListener('notificationclick', event => {
  event.notification.close();
  event.waitUntil(clients.matchAll({ type:'window', includeUncontrolled:true })
    .then(list => {
      for(const c of list) if(c.url==='/'&&c.focus) return c.focus();
      if(clients.openWindow) return clients.openWindow('/');
    })
  );
});

// Subscription change â€“ renew
self.addEventListener('pushsubscriptionchange', event => {
  event.waitUntil(
    self.registration.pushManager.subscribe({
      userVisibleOnly:true,
      applicationServerKey:urlB64ToUint8Array(VAPID_PUBLIC)
    }).then(sub=> fetch('/notifications/subscribe',{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body:JSON.stringify(sub)
    }))
  );
});

// Periodic & Background sync
self.addEventListener('periodicsync', e=> {
  if(e.tag==='fetch-new-items') e.waitUntil(checkForNewData());
  if(e.tag==='store-periodic-notifications') e.waitUntil(storePeriodicNotification());
});
self.addEventListener('sync', e=> {
  if(e.tag==='fetch-new-items') e.waitUntil(checkForNewData());
  if(e.tag==='store-periodic-notifications') e.waitUntil(storePeriodicNotification());
});

// MESSAGE â€“ flush & dummy toggle
self.addEventListener('message', event => {
  const cmd= event.data;
  if(cmd==='FLUSH_NOTIFICATIONS') event.waitUntil(flushNotifications(event.source.id));
  if(cmd.command==='SET_DUMMY_NOTIFICATIONS') event.waitUntil(setDummyNotificationSettings(cmd.enabled));
  if(cmd==='GET_DUMMY_NOTIFICATIONS_STATUS') event.waitUntil(getDummyNotificationStatus(event.source.id));
});

// -- Helper Functions --

async function storePeriodicNotification(){
  const ts=Date.now(), id=`periodic-${ts}`, title='Notifikasi Periodik';
  const opts={ body:`Periodik @ ${new Date(ts).toLocaleString()}`, icon:'/favicon.png', tag:'periodic', timestamp:ts };
  await set(id,{title,options:opts,timestamp:ts},notificationStore);
  (await clients.matchAll({type:'window'})).forEach(c=>
    c.postMessage({type:'NEW_NOTIFICATION',notification:{id,title,options:opts,timestamp:ts}})
  );
}

async function checkForNewData(){
  try{
    const res=await fetch('/api/stories?page=1&size=10');
    if(!res.ok) return;
    const {listStory} = await res.json();
    const lastId = await get('lastId', dataStore);
    for(const item of listStory){
      if(item.id===lastId) break;
      const ts=Date.now(), id=ts.toString(),
            title=`Story baru dari ${item.name}`,
            opts={ body:item.description, icon:'/favicon.png', data:{url:item.photoUrl}, timestamp:ts };
      await set(id,{title,options:opts,timestamp:ts},notificationStore);
      await self.registration.showNotification(title, opts);
    }
    if(listStory.length) await set('lastId', listStory[0].id, dataStore);
  }catch(e){ console.error('checkForNewData error', e) }
}

async function flushNotifications(clientId){
  try{
    const ks=await keys(notificationStore);
    const notes = await Promise.all(ks.map(async k=> {
      const v=await get(k,notificationStore);
      return { id:k, ...v };
    }));
    notes.sort((a,b)=>b.timestamp-a.timestamp);
    const client=await clients.get(clientId);
    if(client) client.postMessage({ type:'PENDING_NOTIFICATIONS', notifications:notes });
  }catch(e){ console.error('flushNotifications error',e) }
}

async function initDummyNotificationSettings(){
  try{
    const s=await get('dummyNotifications',settingsStore);
    if(s===undefined) {
      await set('dummyNotifications',{enabled:false,timerId:null},settingsStore);
    } else if(s.enabled && s.timerId===null) {
      const tid=startDummyNotificationTimer();
      await set('dummyNotifications',{enabled:true,timerId:tid},settingsStore);
    }
  }catch(e){ console.error('initDummyNotificationSettings',e) }
}

async function setDummyNotificationSettings(enabled){
  try{
    const s=await get('dummyNotifications',settingsStore) || {enabled:false,timerId:null};
    if(enabled && !s.enabled){
      const tid=startDummyNotificationTimer();
      await set('dummyNotifications',{enabled:true,timerId:tid},settingsStore);
      (await clients.matchAll({type:'window'})).forEach(c=>c.postMessage({type:'DUMMY_NOTIFICATIONS_STATUS',enabled:true}));
    } else if(!enabled && s.enabled){
      clearInterval(s.timerId);
      await set('dummyNotifications',{enabled:false,timerId:null},settingsStore);
      (await clients.matchAll({type:'window'})).forEach(c=>c.postMessage({type:'DUMMY_NOTIFICATIONS_STATUS',enabled:false}));
    }
  }catch(e){ console.error('setDummyNotificationSettings',e) }
}

async function getDummyNotificationStatus(clientId){
  try{
    const s=await get('dummyNotifications',settingsStore) || {enabled:false};
    const c=await clients.get(clientId);
    if(c) c.postMessage({type:'DUMMY_NOTIFICATIONS_STATUS',enabled:s.enabled});
  }catch(e){ console.error('getDummyNotificationStatus',e) }
}

function startDummyNotificationTimer(){
  return setInterval(async ()=>{
    try{
      const s=await get('dummyNotifications',settingsStore);
      if(!s.enabled) return clearInterval(s.timerId);
      const ts=Date.now(), id=`dummy-${ts}`, title='Notifikasi Dummy';
      const opts={ body:`Dummy @ ${new Date(ts).toLocaleString()}`, icon:'/favicon.png', tag:'dummy', timestamp:ts };
      await set(id,{title,options:opts,timestamp:ts,isDummy:true},notificationStore);
      await self.registration.showNotification(title, opts);
      (await clients.matchAll({type:'window'})).forEach(c=>
        c.postMessage({type:'NEW_NOTIFICATION',notification:{id,title,options:opts,timestamp:ts,isDummy:true}})
      );
    }catch(e){ console.error('dummy timer error',e) }
  },1000);
}

async function cleanupOldDummyNotifications(){
  try{
    const ks=await keys(notificationStore);
    const cutoff=Date.now() - 3600_000;
    for(const k of ks){
      const n=await get(k,notificationStore);
      if(n.isDummy && n.timestamp<cutoff) await del(k,notificationStore);
    }
  }catch(e){ console.error('cleanupOldDummyNotifications',e) }
}

// Cleanup dummy every 6 jam
setInterval(cleanupOldDummyNotifications, 6*3600_000);

index.html:
<!DOCTYPE html>
<html lang="id">
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="StoryApp - Bagikan cerita Anda dengan lokasi"
    />

    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#343a40" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="apple-mobile-web-app-title" content="StoryApp" />
    <link rel="apple-touch-icon" href="images/icons/ios/192.png" />
    <link rel="shortcut icon" href="favicon.png" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css"
    />
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

    <title>StoryApp</title>
    <style>
      /* Tambahan CSS untuk Notifikasi */
      .notifications-panel {
        position: fixed;
        right: 20px;
        top: 70px;
        width: 300px;
        max-height: 400px;
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        overflow: hidden;
        z-index: 1000;
        display: none;
      }
      
      .notifications-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 15px;
        background-color: #343a40;
        color: white;
      }
      
      .notifications-title {
        font-weight: bold;
        margin: 0;
      }
      
      .close-notifications {
        background: none;
        border: none;
        color: white;
        font-size: 18px;
        cursor: pointer;
      }
      
      .notifications-list {
        list-style-type: none;
        margin: 0;
        padding: 0;
        max-height: 350px;
        overflow-y: auto;
      }
      
      .notification-item {
        padding: 12px 15px;
        border-bottom: 1px solid #eee;
      }
      
      .notification-item:last-child {
        border-bottom: none;
      }
      
      .notification-title {
        font-weight: bold;
        margin: 0 0 5px 0;
      }
      
      .notification-body {
        margin: 0;
        color: #666;
        font-size: 14px;
      }
      
      .notification-time {
        font-size: 12px;
        color: #999;
        margin-top: 5px;
      }
      
      .notification-badge {
        position: absolute;
        top: -5px;
        right: -5px;
        background-color: red;
        color: white;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
      }
      
      .notification-bell {
        position: fixed;
        top: 75px;
        right: -120px;
        background-color: #343a40;
        color: white;
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        font-size: 20px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        z-index: 1001;
      }
      
      .dummy-notification-toggle {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background-color: #343a40;
        color: white;
        border: none;
        border-radius: 8px;
        padding: 10px 15px;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        z-index: 1001;
        display: flex;
        align-items: center;
      }
      
      .switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
        margin-left: 10px;
      }
      
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      
      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
        border-radius: 24px;
      }
      
      .slider:before {
        position: absolute;
        content: "";
        height: 16px;
        width: 16px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
      }
      
      input:checked + .slider {
        background-color: #2196F3;
      }
      
      input:checked + .slider:before {
        transform: translateX(26px);
      }
      
      .no-notifications {
        padding: 20px;
        text-align: center;
        color: #666;
      }
      
      /* Responsive adjustments */
      @media (max-width: 600px) {
        .notifications-panel {
          width: 90%;
          right: 5%;
          left: 5%;
        }
        
        .notification-bell {
          right: 20px;
        }
      }
    </style>
  </head>
  <body>
    <a href="#main-content" class="skip-link" id="skip-to-content"
      >Lewati ke konten utama</a
    >

    <header>
      <div class="main-header container">
        <a class="brand-name" href="#/">
          <img src="images/logo.png" alt="Logo StoryApp" class="logo" />
          StoryApp
        </a>

        <nav
          id="navigation-drawer"
          class="navigation-drawer"
          aria-label="Navigasi Utama"
        >
          <ul id="nav-list" class="nav-list">
            <li><a href="#/">Beranda</a></li>
            <li><a href="#/map">Tampilan Peta</a></li>

            <div id="user-nav" class="hidden">
              <li><a href="#/add" class="add-story-btn">Tambah Cerita</a></li>
            </div>

            <li><a href="#/about">Tentang</a></li>

            <div id="user-nav-2" class="hidden">
              <li>
                <button id="logout-btn" class="logout-btn">Keluar</button>
              </li>
            </div>

            <div id="auth-nav">
              <li><a href="#/login">Masuk</a></li>
              <li><a href="#/register">Daftar</a></li>
            </div>
          </ul>
        </nav>

        <button
          id="drawer-button"
          class="drawer-button"
          aria-label="Tombol menu"
        >
          â˜°
        </button>
      </div>
    </header>

    <!-- Notifikasi Bell Button -->
    <button id="notification-bell" class="notification-bell" aria-label="Notifikasi">
      ðŸ””
      <span id="notification-badge" class="notification-badge" style="display: none;">0</span>
    </button>

    <!-- Notifications Panel -->
    <div id="notifications-panel" class="notifications-panel">
      <div class="notifications-header">
        <h3 class="notifications-title">Notifikasi</h3>
        <button id="close-notifications" class="close-notifications" aria-label="Tutup panel notifikasi">Ã—</button>
      </div>
      <ul id="notifications-list" class="notifications-list">
        <!-- Notifications will be inserted here dynamically -->
        <li class="no-notifications">Tidak ada notifikasi</li>
      </ul>
    </div>

    <!-- Dummy Notification Toggle -->
    <div id="dummy-notification-toggle" class="dummy-notification-toggle">
      Notifikasi Dummy
      <label class="switch">
        <input type="checkbox" id="dummy-notification-switch">
        <span class="slider"></span>
      </label>
    </div>

    <main id="main-content" class="main-content" tabindex="2"></main>

    <footer>
      <div class="container">
        <p>&copy; 2025 StoryApp - Bagikan cerita Anda dengan lokasi</p>
      </div>
    </footer>

    <script>
      // Auth Navigation Logic
      const authNav = document.getElementById("auth-nav");
      const userNav = document.getElementById("user-nav");
      const userNav2 = document.getElementById("user-nav-2");

      function updateNav() {
        const sudahMasuk = !!localStorage.getItem("storyapp_auth");
        if (sudahMasuk) {
          authNav.classList.add("hidden");
          userNav.classList.remove("hidden");
          userNav2.classList.remove("hidden");
        } else {
          authNav.classList.remove("hidden");
          userNav.classList.add("hidden");
          userNav2.classList.add("hidden");
        }
      }

      // Jalankan saat halaman dimuat
      updateNav();

      // Pendengar untuk tombol keluar
      document.getElementById("logout-btn")?.addEventListener("click", () => {
        localStorage.removeItem("storyapp_auth");
        window.location.hash = "#/";
        window.location.reload();
      });

      // ========== NOTIFICATION SYSTEM ==========
      
      // Elemen UI notifikasi
      const notificationBell = document.getElementById('notification-bell');
      const notificationBadge = document.getElementById('notification-badge');
      const notificationsPanel = document.getElementById('notifications-panel');
      const closeNotifications = document.getElementById('close-notifications');
      const notificationsList = document.getElementById('notifications-list');
      const dummyNotificationSwitch = document.getElementById('dummy-notification-switch');
      
      // Variabel untuk menyimpan notifikasi
      let notifications = [];
      let unreadCount = 0;
      
      // Format waktu untuk notifikasi
      function formatTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleString('id-ID', { 
          day: 'numeric', 
          month: 'short', 
          year: 'numeric',
          hour: '2-digit', 
          minute: '2-digit' 
        });
      }
      
      // Tampilkan notifikasi di panel
      function renderNotifications() {
        if (notifications.length === 0) {
          notificationsList.innerHTML = '<li class="no-notifications">Tidak ada notifikasi</li>';
          return;
        }
        
        notificationsList.innerHTML = '';
        notifications.forEach(notification => {
          const li = document.createElement('li');
          li.className = 'notification-item';
          li.innerHTML = `
            <h4 class="notification-title">${notification.title}</h4>
            <p class="notification-body">${notification.options.body}</p>
            <p class="notification-time">${formatTime(notification.timestamp)}</p>
          `;
          notificationsList.appendChild(li);
        });
      }
      
      // Update badge notifikasi
      function updateNotificationBadge() {
        if (unreadCount > 0) {
          notificationBadge.textContent = unreadCount > 99 ? '99+' : unreadCount;
          notificationBadge.style.display = 'flex';
        } else {
          notificationBadge.style.display = 'none';
        }
      }
      
      // Toggle panel notifikasi
      notificationBell.addEventListener('click', () => {
        const isVisible = notificationsPanel.style.display === 'block';
        notificationsPanel.style.display = isVisible ? 'none' : 'block';
        
        if (!isVisible) {
          // Reset counter saat panel dibuka
          unreadCount = 0;
          updateNotificationBadge();
        }
      });
      
      // Tutup panel notifikasi
      closeNotifications.addEventListener('click', () => {
        notificationsPanel.style.display = 'none';
      });
      
      // Toggle notifikasi dummy
      dummyNotificationSwitch.addEventListener('change', () => {
        toggleDummyNotifications(dummyNotificationSwitch.checked);
      });
      
      // Fungsi untuk mengaktifkan/menonaktifkan notifikasi dummy
      function toggleDummyNotifications(enabled) {
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.ready.then(registration => {
            registration.active.postMessage({
              command: 'SET_DUMMY_NOTIFICATIONS',
              enabled: enabled
            });
          });
        }
      }
      
      // Minta izin notifikasi
      async function requestNotificationPermission() {
        if ('Notification' in window) {
          const permission = await Notification.requestPermission();
          return permission === 'granted';
        }
        return false;
      }
      
      // Setup Push Notification
      async function setupPushNotification() {
        if (!('PushManager' in window)) {
          console.log('Push notification tidak didukung');
          return;
        }
        
        try {
          const hasPermission = await requestNotificationPermission();
          if (!hasPermission) {
            console.log('Izin notifikasi ditolak');
            return;
          }
          
          const registration = await navigator.serviceWorker.ready;
          const subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: urlB64ToUint8Array('BCCs2eonMI-6H2ctvFaWg-UYdDv387Vno_bzUzALpB442r2lCnsHmtrx8biyPi_E-1fSGABK_Qs_GlvPoJJqxbk')
          });
          
          // Kirim subscription ke server
          console.log('Push subscription berhasil:', subscription);
          
          // TODO: Kirim ke server API dengan fetch
          // await fetch('/notifications/subscribe', {
          //   method: 'POST', 
          //   headers: {'Content-Type': 'application/json'},
          //   body: JSON.stringify(subscription)
          // });
        } catch (error) {
          console.error('Gagal setup push notification:', error);
        }
      }
      
      // Mengkonversi VAPID key
      function urlB64ToUint8Array(base64) {
        const padding = '='.repeat((4 - base64.length % 4) % 4);
        const b64 = (base64 + padding).replace(/-/g, '+').replace(/_/g, '/');
        const raw = atob(b64);
        const arr = new Uint8Array(raw.length);
        for (let i = 0; i < raw.length; i++) arr[i] = raw.charCodeAt(i);
        return arr;
      }
      
      // Jalankan saat halaman dimuat
      document.addEventListener('DOMContentLoaded', async () => {
        // Izin notifikasi
        await setupPushNotification();
      });

      // ========== SERVICE WORKER INTEGRATION ==========
      
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          // Registrasi Service Worker
          navigator.serviceWorker
            .register("/sw.js")
            .then((registration) => {
              console.log(
                "ServiceWorker registration successful with scope: ",
                registration.scope
              );
              
              // Setelah Service Worker aktif, minta notifikasi tersimpan
              if (registration.active) {
                registration.active.postMessage('FLUSH_NOTIFICATIONS');
                registration.active.postMessage('GET_DUMMY_NOTIFICATIONS_STATUS');
              }
            })
            .catch((error) => {
              console.log("ServiceWorker registration failed: ", error);
            });
            
          // Menangani pesan dari Service Worker
          navigator.serviceWorker.addEventListener('message', event => {
            const data = event.data;
            
            if (data.type === 'PENDING_NOTIFICATIONS') {
              // Terima notifikasi tersimpan
              console.log('Menerima notifikasi tersimpan:', data.notifications);
              notifications = data.notifications || [];
              renderNotifications();
            } 
            else if (data.type === 'NEW_NOTIFICATION') {
              // Notifikasi baru diterima
              console.log('Menerima notifikasi baru:', data.notification);
              notifications.unshift(data.notification);
              unreadCount++;
              updateNotificationBadge();
              renderNotifications();
            }
            else if (data.type === 'DUMMY_NOTIFICATIONS_STATUS') {
              // Update status toggle notifikasi dummy
              console.log('Status notifikasi dummy:', data.enabled);
              dummyNotificationSwitch.checked = data.enabled;
            }
          });
        });
        
        // Minta flush notifikasi ketika halaman difokuskan
        window.addEventListener('focus', () => {
          if (navigator.serviceWorker.controller) {
            navigator.serviceWorker.controller.postMessage('FLUSH_NOTIFICATIONS');
          }
        });
      }
    </script>
  </body>
</html>

Buat kode lengkap sw.js dan index.html. Buat tanpa menggunakan canvas. Gunakan workbox untuk caching offline data dari url.

Konteks:
I'll help you enhance your service worker (sw.js) to implement the IndexedDB functionality for fetching new data from the API, storing it, and displaying periodic notifications. I'll also make sure to include proper Workbox integration for caching offline data.Let's start by creating the updated sw.js file:sw.jsKode // sw.js â€“ Complete Service Worker with error-tolerant install handler // Using Workbox for better caching strategies importScripts('https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js'); importScripts('https://cdn.jsdelivr.net/nNow, let's update the index.html file to work with our enhanced service worker:Membuat artefak... Coba lagiRespons ini terhenti karena Claude telah mencapai batas maksimum panjang pesan. Tekan lanjutkan untuk melanjutkan respons Claude. Lanjutkan pembuatan index.html
